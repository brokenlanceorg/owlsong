//***********************************************************************************************
// File     : RollingNetwork.cpp
// Purpose  : A rolling network object is created and run exclusively programatically
//          : Thus, when the object is created, it needs to check to see whether or
//          : not the network is alive.
//          :
//          :
//          :
//          :
// Author   : Brandon Benham
// Date     : 5/3/05
//***********************************************************************************************

#include"RollingNetwork.hpp"
#include <iomanip>
#include <iostream>

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : Default Constructor
// Purpose  : Performs the basic construction actions.
//***********************************************************************************************
RollingNetworK::RollingNetworK()
{
   Setup();
} // end RollingNetworK default constructor

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : Constructor
// Purpose  : Performs the construction actions.
// Notes    : Assumes that the file name doesn't include the extension
//***********************************************************************************************
RollingNetworK::RollingNetworK( char* baseFileName, int depth, int inputs, 
                                int outputs, int hidden, unsigned short check )
{
   Setup();
   char fileName[30];
   unsigned short alive = 0;
   fileName[0] = '\0';
   strcpy( _outputFileName, baseFileName );
   strcpy( fileName, baseFileName );
   strcat( fileName, ".def" );
   strcat( _outputFileName, ".fac" );
   _depth = depth;

   if( check && DoesFileExist( _outputFileName ) )
   {
      alive = 1;
   }
   else
   {
      CreateDefaultFiles( fileName, inputs, outputs, hidden );
   }

   _geneticNetwork = new GeneticNeuralNetworK( fileName, alive );

/** Not really needed since this wasn't shown to improve performance
   if( alive == 0 )
   {
      PopulateSynapses();
   }
*/
} // end RollingNetworK constructor

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : Destructor
// Purpose  : Performs the destruction actions.
//***********************************************************************************************
RollingNetworK::~RollingNetworK()
{
   if( _geneticNetwork != 0 )
   {
      delete _geneticNetwork;
      _geneticNetwork = 0;
   }
} // end RollingNetworK destructor

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : DoesFileExist
// Purpose  : 
//***********************************************************************************************
bool RollingNetworK::DoesFileExist( char* fileName )
{
   bool isExisting = false;
   fstream theFile( _outputFileName, ios::in );

   if( theFile.is_open() )
   {
      isExisting = true;
   }
   theFile.close();

   return isExisting;
}

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : CreateDefaultFiles
// Purpose  : 
//***********************************************************************************************
void RollingNetworK::CreateDefaultFiles( char* definitionFile, int inputs, int outputs, int hidden )
{
   ofstream outputFile( definitionFile, ios::trunc );
   outputFile << "// This file was generated by a RollingNetwork object.\n";
   outputFile << "INPUTS " << inputs << " OUTPUTS " << outputs << " HIDDEN " << hidden;
   outputFile << " MOMENTUM 0.8 TOLERANCE 0.001 RATE 2\n";
   outputFile.close();

   WriteDefaultFactFile();
}

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : CreateDefaultFiles
// Purpose  : 
//***********************************************************************************************
void RollingNetworK::WriteDefaultFactFile()
{
   ofstream factFile( _outputFileName, ios::trunc );
   factFile << "// This file was generated by a RollingNetwork object.\n";
   factFile << "0\n";
   factFile.close();
}

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : Setup
// Purpose  : Performs the basic setup actions.
//***********************************************************************************************
void RollingNetworK::Setup()
{
   _depth = 0;
   _geneticNetwork = 0;
   _outputFileName[0] = '\0';
} // end Setup

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : 
// Purpose  : 
//          : 
//          : 
//          :
//          : 
//          : 
//***********************************************************************************************
void RollingNetworK::PopulateSynapses()
{
   MatriX* synOne = _geneticNetwork->GetSynapseOne();
   FilereadeR* theInputFile = new FilereadeR( "SynOne.txt" );
   //theInputFile->Rewind();
   char* theWord = 0;

   for( int i=0; i<synOne->cnRows; i++ )
   {
      for( int j=0; j<synOne->cnColumns; j++ )
      {
         theWord = theInputFile->GetNextWord();
         synOne->pCol[i][j] = strtold( theWord, (char**)NULL );
//cout << "setting value: " << synOne->pCol[i][j] << endl;
      }
   }

   delete theInputFile;

   MatriX* synTwo = _geneticNetwork->GetSynapseTwo();
   FilereadeR theInputFile2( "SynTwo.txt" );
   theInputFile2.Rewind();
   theWord = 0;

   for( int i=0; i<synTwo->cnRows; i++ )
   {
      for( int j=0; j<synTwo->cnColumns; j++ )
      {
         theWord = theInputFile2.GetNextWord();
         synTwo->pCol[i][j] = strtold( theWord, (char**)NULL );
//cout << "setting value 2: " << synTwo->pCol[i][j] << endl;
      }
   }

   //delete theInputFile2;
}

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : 
// Purpose  : 
//          : 
//          : 
//          :
//          : 
//          : 
//***********************************************************************************************
void RollingNetworK::WriteFactFile()
{
   MatriX* newInputMatrix = _geneticNetwork->GetInputMatrix();
   MatriX* newOutputMatrix = _geneticNetwork->GetOutputMatrix();

   ofstream outputFile( _outputFileName, ios::out | ios::trunc );
   outputFile << setprecision( 12 );
   outputFile << "// This file was generated by a RollingNetwork object\n";
   outputFile << newInputMatrix->cnRows << " ";

   for( int i=0; i<newInputMatrix->cnRows; i++ )
   {
      for( int j=0; j<newInputMatrix->cnColumns; j++ )
      {
         outputFile << newInputMatrix->pCol[i][j] << " ";
      }
      outputFile << "\n";

      for( int j=0; j<newOutputMatrix->cnColumns; j++ )
      {
         outputFile << newOutputMatrix->pCol[i][j] << " ";
      }
      outputFile << "\n";
   }
   outputFile.close();

}

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : 
// Purpose  :  DEPRECATED
//          : 
//          : 
//          :
//          : 
//          : 
//***********************************************************************************************
void RollingNetworK::RollbackTrainingInstance()
{
   MatriX* trainingInput = _geneticNetwork->GetInputMatrix();
   MatriX* trainingOutput = _geneticNetwork->GetOutputMatrix();

   int numberOfInstances = trainingInput->cnRows - 1;
   int numberOfInputColumns = trainingInput->cnColumns;
   int numberOfOutputColumns = trainingOutput->cnColumns;

   if( numberOfInstances == -1 )
   {
      return;
   }

   MatriX* newInputMatrix = new MatriX( numberOfInstances, numberOfInputColumns );
   MatriX* newOutputMatrix = new MatriX( numberOfInstances, numberOfOutputColumns );

   newInputMatrix->Zero_Out();
   newOutputMatrix->Zero_Out();

   for( int i=0; i<numberOfInstances; i++ )
   {
      for( int j=0; j<numberOfInputColumns; j++ )
      {
         newInputMatrix->pCol[i][j] = trainingInput->pCol[i][j];
      }

      for( int j=0; j<numberOfOutputColumns; j++ )
      {
         newOutputMatrix->pCol[i][j] = trainingOutput->pCol[i][j];
      }
   }

   // don't forget to update the number of instances in the network object!
   _geneticNetwork->SetNumberOfInstances( numberOfInstances );
   _geneticNetwork->SetTrainingInputMatrix( newInputMatrix );
   _geneticNetwork->SetTrainingOutputMatrix( newOutputMatrix );

   ofstream outputFile( _outputFileName, ios::out | ios::trunc );
   outputFile << setprecision( 12 );
   outputFile << "// This file was generated by a RollingNetwork object\n";
   outputFile << numberOfInstances << " ";
   for( int i=0; i<numberOfInstances; i++ )
   {
      for( int j=0; j<numberOfInputColumns; j++ )
      {
         outputFile << newInputMatrix->pCol[i][j] << " ";
      }
      outputFile << "\n";

      for( int j=0; j<numberOfOutputColumns; j++ )
      {
         outputFile << newOutputMatrix->pCol[i][j] << " ";
      }
      outputFile << "\n";
   }
   outputFile.close();

}

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : AddTrainingPair
// Purpose  : This will add a pair of training data to the rolling network.
//          : If the instance number exceeds the depth, then the first in is first out,
//          : and the new pair added.
//          : We will go ahead and update the data file at this point.
//          : 
//          : 
//***********************************************************************************************
void RollingNetworK::AddTrainingPair( VectoR* input, VectoR* output )
{
   MatriX* trainingInput = _geneticNetwork->GetInputMatrix();
   MatriX* trainingOutput = _geneticNetwork->GetOutputMatrix();

   int numberOfInstances = trainingInput->cnRows;
   int numberOfInputColumns = trainingInput->cnColumns;
   int numberOfOutputColumns = trainingOutput->cnColumns;
   int offset = 0;

   if( numberOfInstances < _depth )
   {
      numberOfInstances++;
   }
   else
   {
      offset = 1;
   }

   MatriX* newInputMatrix = new MatriX( numberOfInstances, numberOfInputColumns );
   MatriX* newOutputMatrix = new MatriX( numberOfInstances, numberOfOutputColumns );

   newInputMatrix->Zero_Out();
   newOutputMatrix->Zero_Out();

   for( int i=0; i<numberOfInstances; i++ )
   {
      for( int j=0; j<numberOfInputColumns; j++ )
      {
         if( i == (numberOfInstances - 1) )
         {
            newInputMatrix->pCol[i][j] = input->pVariables[j];
         }
         else
         {
            newInputMatrix->pCol[i][j] = trainingInput->pCol[i + offset][j];
         }
      }

      for( int j=0; j<numberOfOutputColumns; j++ )
      {
         if( i == (numberOfInstances - 1) )
         {
            newOutputMatrix->pCol[i][j] = output->pVariables[j];
         }
         else
         {
            newOutputMatrix->pCol[i][j] = trainingOutput->pCol[i + offset][j];
         }
      }
   }

   _geneticNetwork->SetNumberOfInstances( numberOfInstances );
   _geneticNetwork->SetTrainingInputMatrix( newInputMatrix );
   _geneticNetwork->SetTrainingOutputMatrix( newOutputMatrix );
}

//***********************************************************************************************
// Class    : RollingNetworK
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Method   : GetNumberOfInstances
// Purpose  : 
//          : 
//***********************************************************************************************
int RollingNetworK::GetNumberOfInstances()
{
   int number = 0;

   if( _geneticNetwork != 0 )
   {
      number = _geneticNetwork->GetNumberOfInstances();
   }

   return number;
}
